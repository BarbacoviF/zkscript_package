from tx_engine import Script


class MerkleTree:
    """Class representing a Merkle Tree.

    This class takes a root hash and a specified hash function to create the Merkle Tree
    structure.

    Attributes:
        root (str): The root hash of the Merkle Tree. Must be a valid hexadecimal value.
        hash_function (str): The hash function used in the Merkle Tree. This must be a valid opcode hash function or a
            combination of valid opcode hash functions.

    Methods:
        __init__(root: str, hash_function: str): Initializes the Merkle Tree. An assertion is
            performed to ensure the hash function is valid and the root is hexadecimal.

    """

    def __init__(self, root: str, hash_function: str):
        assert all(c in "0123456789abcdefABCDEF" for c in root), f"{root} is not a valid hexadecimal string."

        assert set(hash_function.split(" ")).issubset(
            {"OP_RIPEMD160", "OP_SHA1", "OP_SHA256", "OP_HASH160", "OP_HASH256"}
        ), f"{hash_function} is not a valid hash function."

        self.root = root
        self.hash_function = hash_function

    def locking_merkle_proof_one_path(
        self,
        nodes: list[str],
        is_nodes_left: list[bool],
        is_equal_verify: bool = False,
    ) -> Script:
        """Generate a locking script requiring knowledge of a specific leaf in a Merkle tree.

        Args:
            nodes: A list of hexadecimal strings representing the hash values of nodes.
            is_nodes_left: A list of boolean values specifing if the value in the list node is a left child of the
                parent node. If `is_nodes_left = True`, the values are swapped to the correct position.
            is_equal_verify: a boolean variable to choose between `OP_EQUAL` or `OP_EQUALVERIFY` as final opcode in the
                script. Default to `False`.

        Returns:
            A locking script verifying a specific path to the Merkle root.

        The function iterates through each node in the `nodes` list, adding a swap command if the upcoming node is a
        left child.

        Note:
            - `self.hash_function` must be a combination of valid Bitcoin Script hash functions (e.g., `OP_SHA256`).
            - `self.root` must be set to the expected Merkle root to verify against.

        """

        assert len(nodes) == len(is_nodes_left), f"{nodes} and {is_nodes_left} have different lenght."
        assert all(
            c in "0123456789abcdefABCDEF" for node in nodes for c in node
        ), f"{nodes} is not a valid list of hexadecimal strings."

        out = Script()

        for node, position in zip(nodes, is_nodes_left):
            out.append_pushdata(bytes.fromhex(node))
            if position:
                out += Script.parse_string("OP_SWAP")
            out += Script.parse_string("OP_CAT")
            out += Script.parse_string(self.hash_function)

        out.append_pushdata(bytes.fromhex(self.root))
        out += Script.parse_string("OP_EQUALVERIFY") if is_equal_verify else Script.parse_string("OP_EQUAL")

        return out

    def locking_merkle_proof_any_path(
        self,
        depth: int,
        is_equal_verify: bool = False,
    ) -> Script:
        """Generate a script to verify a Merkle path of a certain lenght against a fixed Merkle root.

        Args:
            depth: An integer representing the depth of the Merkle tree.
            is_equal_verify: a boolean variable to choose between `OP_EQUAL` or `OP_EQUALVERIFY` as final opcode in the
                script. Default to `False`.

        Returns:
            A locking script verifying any valid path to the Merkle root.

        The function generates a locking script that can be unlocked by valid Merkle path of length `depth`.

        Note:
            - `self.hash_function` must be a combination of valid Bitcoin Script hash functions (e.g., `OP_SHA256`).
            - `self.root` must be set to the expected Merkle root to verify against.

        """

        assert depth > 0

        out = Script.parse_string("OP_CAT")
        out += Script.parse_string(self.hash_function)

        for _ in range(depth - 1):
            out += Script.parse_string("OP_SWAP OP_CAT OP_CAT")
            out += Script.parse_string(self.hash_function)

        out.append_pushdata(bytes.fromhex(self.root))

        out += Script.parse_string("OP_EQUALVERIFY") if is_equal_verify else Script.parse_string("OP_EQUAL")

        return out

    def unlocking_merkle_proof_one_path(
        self,
        node: str,
    ) -> Script:
        """Generate a locking script requiring knowledge of a specific leaf in a Merkle tree.

        Args:
            node: An hexidecimal string representing the hash value of a leave in hex.

        Returns:
            The unlocking script for the script generated by `locking_merkle_proof_one_path`.

        Note:
            - `self.hash_function` must be a combination of valid Bitcoin Script hash functions (e.g., `OP_SHA256`).
            - `self.root` must be set to the expected Merkle root to verify against.

        """
        assert all(c in "0123456789abcdefABCDEF" for c in node), f"{node} is not a valid hexadecimal strings."

        out = Script()

        out.append_pushdata(bytes.fromhex(node))

        return out

    def unlocking_merkle_proof_any_path(
        self,
        left_nodes: list[str],
        right_nodes: list[str],
    ) -> Script:
        """Generate a script to verify a Merkle path of a certain lenght.

        Args:
            left_nodes: A list of hexidecimal strings representing the left elements in the Merkle path. If the left
                element is not needed at that level, use `""`. The element at the end of the list represent a leaf node.
            right_nodes: A list of hexidecimal strings representing the right elements in the Merkle path. If the right
                element is not needed at that level, use `""`. The element at the end of the list represent a leaf node.


        Returns:
            The unlocking script for the script generated by `locking_merkle_proof_one_path`.

        Note:
            - `self.hash_function` must be a combination of valid Bitcoin Script hash functions (e.g., `OP_SHA256`).
            - `self.root` must be set to the expected Merkle root to verify against.

        """
        assert all(
            c in "0123456789abcdefABCDEF" for node in left_nodes for c in node
        ), f"{left_nodes} is not a valid list of hexadecimal strings."

        assert all(
            c in "0123456789abcdefABCDEF" for node in right_nodes for c in node
        ), f"{right_nodes} is not a valid list of hexadecimal strings."

        assert len(left_nodes) == len(right_nodes), f"{nodes} and {is_nodes_left} have different lenght."

        out = Script()

        for left_node, right_node in zip(left_nodes, right_nodes):
            out.append_pushdata(bytes.fromhex(left_node))
            out.append_pushdata(bytes.fromhex(right_node))

        return out
